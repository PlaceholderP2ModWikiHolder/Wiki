{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the PlaceholderMod Wiki PlaceholderMod is a Portal 2 mod built on a unique engine that can differ significantly from the original Source Engine. This wiki is designed to make the process of developing third-party content for PlaceholderMod easy and well-documented. Currently, PlaceholderMod supports Code Mods, Content Mods, and standalone game-like mods. To get started with creating a Mod see Intro to Modding References Entity System VistaGUI Modding Editor File System","title":"About"},{"location":"#welcome-to-the-placeholdermod-wiki","text":"PlaceholderMod is a Portal 2 mod built on a unique engine that can differ significantly from the original Source Engine. This wiki is designed to make the process of developing third-party content for PlaceholderMod easy and well-documented. Currently, PlaceholderMod supports Code Mods, Content Mods, and standalone game-like mods. To get started with creating a Mod see Intro to Modding","title":"Welcome to the PlaceholderMod Wiki"},{"location":"editor/editorentities/","text":"Editor Entities When expanding the Editor, you may want to create an Entity that can run code in the Editor. To do this, you can use the [AlwaysExecute] Attribute on the Entity class. This Example will print \"Editor Update logic\" once per update in the Editor. [AlwaysExecute] public class MyEditorEntity : BaseEntity { public override void Update() { Console.Log(\"Editor Update logic\"); } } Note [AlwaysExecute] Will run Entity logic both In-Editor and In-Game.","title":"Editor Entities"},{"location":"editor/editorentities/#editor-entities","text":"When expanding the Editor, you may want to create an Entity that can run code in the Editor. To do this, you can use the [AlwaysExecute] Attribute on the Entity class. This Example will print \"Editor Update logic\" once per update in the Editor. [AlwaysExecute] public class MyEditorEntity : BaseEntity { public override void Update() { Console.Log(\"Editor Update logic\"); } } Note [AlwaysExecute] Will run Entity logic both In-Editor and In-Game.","title":"Editor Entities"},{"location":"editor/gizmos/","text":"Gizmos When creating an Entity you may want to assign a custom Editor Gizmo. This can be acheived by overriding the DrawGizmos() and DrawGizmosSelected() functions of the Entity respectively. Note To prevent Gizmo-related code from being included in the shipped game when not in use, wrap these functions in a #if EDITOR directive. Rendering Primitives The Gizmos class offers features for rendering different types of Primitives within your Gizmos. To set the Color of a Primitive you can set Gizmos.Color before rendering the Primitive. #if EDITOR public override void DrawGizmos() { // Draw a Red Cube sized at 32 units at the Entity position Gizmos.Color = new Vector4(255, 0, 0, 1); Gizmos.DrawCube(Transform.Position, new Vector3(32.0f, 32.0f, 32.0f)); } #endif Warning Gizmo Primitives are not parented to the Entity by default.","title":"Gizmos"},{"location":"editor/gizmos/#gizmos","text":"When creating an Entity you may want to assign a custom Editor Gizmo. This can be acheived by overriding the DrawGizmos() and DrawGizmosSelected() functions of the Entity respectively. Note To prevent Gizmo-related code from being included in the shipped game when not in use, wrap these functions in a #if EDITOR directive.","title":"Gizmos"},{"location":"editor/gizmos/#rendering-primitives","text":"The Gizmos class offers features for rendering different types of Primitives within your Gizmos. To set the Color of a Primitive you can set Gizmos.Color before rendering the Primitive. #if EDITOR public override void DrawGizmos() { // Draw a Red Cube sized at 32 units at the Entity position Gizmos.Color = new Vector4(255, 0, 0, 1); Gizmos.DrawCube(Transform.Position, new Vector3(32.0f, 32.0f, 32.0f)); } #endif Warning Gizmo Primitives are not parented to the Entity by default.","title":"Rendering Primitives"},{"location":"editor/plugins/","text":"Editor Plugins The Editor allows for functionality to be extended through Plugins. Internally, plugins are essentially the same as Mods, with the only difference being a plugin's .dll links to both Engine.dll and Editor.dll .","title":"Editor Plugins"},{"location":"editor/plugins/#editor-plugins","text":"The Editor allows for functionality to be extended through Plugins. Internally, plugins are essentially the same as Mods, with the only difference being a plugin's .dll links to both Engine.dll and Editor.dll .","title":"Editor Plugins"},{"location":"entities/entityintro/","text":"Intro To Entities PlaceholderMod allows the creation of Entities through C# Scripting. To define an Entity, you need to inherit from BaseEntity and override OnStart() and OnUpdate() methods for all logic. public class MyEntity : BaseEntity { // This will run once on Start public override void Start() { Console.WriteLine(\"Starting MyEntity...\"); } // This will run once per frame public override void Update() { Console.WriteLine(\"Updating MyEntity!\"); } } Exposing Entity Variables to the Editor To expose an Entity Variable to the Editor, you can utilize the [EntityProperty] Attribute. Any Variables marked with this Attribute will be accessible and editable directly from the Editor. [EntityProperty(\"light_color\")] public Vector4 Color = new Vector4(255.0f, 255.0f, 255.0f, 200.0f); Warning Entity Properties only support the Datatypes that the KeyValues format supports. Entity Deletion Entities can be deleted through the Entity.DestroyDeferred() method. This method will clean up the Entities with their OnDestroy() method before deleting it from the world. // Run any Entity clean-up and then remove it from the World EntityReference.DestroyDeferred(); Entity Types Entities come in 2 primary types, Point Entities and Brush Entities. Point Entity A Point Entity is an Entity that occupies a single point in the world. public class PropEntity : MeshEntity { /// <summary> /// Create Mesh from this path. /// </summary> [EntityProperty(\"model\")] public string MeshPath; /// <summary> /// Get Material from this path. /// </summary> [EntityProperty(\"skin\")] public string MaterialPath; public override void Start() { Material material = FileSystem.GetMaterial(MaterialPath); Mesh = new Mesh(FileSystem.GetModelPath(MeshPath), material); GameWindow.CurrentWindow.Renderer.InitMesh(Mesh); // Render the (empty) mesh } } Brush Entity A Brush Entity is an Entity that occupies Map Geometry (Brushes).","title":"Intro to Entities"},{"location":"entities/entityintro/#intro-to-entities","text":"PlaceholderMod allows the creation of Entities through C# Scripting. To define an Entity, you need to inherit from BaseEntity and override OnStart() and OnUpdate() methods for all logic. public class MyEntity : BaseEntity { // This will run once on Start public override void Start() { Console.WriteLine(\"Starting MyEntity...\"); } // This will run once per frame public override void Update() { Console.WriteLine(\"Updating MyEntity!\"); } }","title":"Intro To Entities"},{"location":"entities/entityintro/#exposing-entity-variables-to-the-editor","text":"To expose an Entity Variable to the Editor, you can utilize the [EntityProperty] Attribute. Any Variables marked with this Attribute will be accessible and editable directly from the Editor. [EntityProperty(\"light_color\")] public Vector4 Color = new Vector4(255.0f, 255.0f, 255.0f, 200.0f); Warning Entity Properties only support the Datatypes that the KeyValues format supports.","title":"Exposing Entity Variables to the Editor"},{"location":"entities/entityintro/#entity-deletion","text":"Entities can be deleted through the Entity.DestroyDeferred() method. This method will clean up the Entities with their OnDestroy() method before deleting it from the world. // Run any Entity clean-up and then remove it from the World EntityReference.DestroyDeferred();","title":"Entity Deletion"},{"location":"entities/entityintro/#entity-types","text":"Entities come in 2 primary types, Point Entities and Brush Entities.","title":"Entity Types"},{"location":"entities/entityintro/#point-entity","text":"A Point Entity is an Entity that occupies a single point in the world. public class PropEntity : MeshEntity { /// <summary> /// Create Mesh from this path. /// </summary> [EntityProperty(\"model\")] public string MeshPath; /// <summary> /// Get Material from this path. /// </summary> [EntityProperty(\"skin\")] public string MaterialPath; public override void Start() { Material material = FileSystem.GetMaterial(MaterialPath); Mesh = new Mesh(FileSystem.GetModelPath(MeshPath), material); GameWindow.CurrentWindow.Renderer.InitMesh(Mesh); // Render the (empty) mesh } }","title":"Point Entity"},{"location":"entities/entityintro/#brush-entity","text":"A Brush Entity is an Entity that occupies Map Geometry (Brushes).","title":"Brush Entity"},{"location":"entities/globalentities/","text":"Global Entities Global Entities are Entities that maintain a persistent state across maps. When a map is unloaded, Global Entities remain intact. The Start() method of a Global Entity is executed once upon game launch. Creating Global Entities To create a Global Entity in C#, you can use the EntityManager.AddGlobalEntity() method. BaseEntity myEntity = new BaseEntity(); EntityManager.AddGlobalEntity(myEntity);","title":"Global Entities"},{"location":"entities/globalentities/#global-entities","text":"Global Entities are Entities that maintain a persistent state across maps. When a map is unloaded, Global Entities remain intact. The Start() method of a Global Entity is executed once upon game launch.","title":"Global Entities"},{"location":"entities/globalentities/#creating-global-entities","text":"To create a Global Entity in C#, you can use the EntityManager.AddGlobalEntity() method. BaseEntity myEntity = new BaseEntity(); EntityManager.AddGlobalEntity(myEntity);","title":"Creating Global Entities"},{"location":"fileformats/keyvalues/","text":"KeyValues File Format During Mod development, you might need to store data in an easy-to-use text format. For this purpose, we use Valve's KeyValues format. Parent Keys Parent Keys contain Nested Parent Keys and Key Values. They are defined by a name, followed by an opening curly brace { , the contents of the Parent Key, and a closing curly brace } . Name { any other parent keys or key values would go here. } Key Values Key Values contain accessible variable data in text form. They are defined by a Key (Name), followed by an indent and the desired Value. Name \"Value\" Supported Value Datatypes Type Formatting Example Integer \"123\" Float \"123.1\" Boolean \"true\" String \"string\" Vector3 \"(1 2 3)\" OR \"1 2 3\" Vector4 \"(1 2 3 4)\" OR \"1 2 3 4\" C# API The KeyValues Format can be parsed through the KeyValuesFormat Class. This Class breaks a KeyValues file into the following structure. ParentKey \u251c\u2500\u2500 ChildParentKey \u2502 \u251c\u2500\u2500 ChildKeyValue \u2502 \u2514\u2500\u2500 ChildKeyValue \u2514\u2500\u2500 ChildKeyValue To parse a KeyValue file using the C# API, first read the file contents, then create a new instance of the KeyValuesFormat class like this: new KeyValuesFormat(file_contents) GameInfo Example The following is an example of parsing a KeyValues file and getting Values from it to parse GameInfo.txt: /// <summary> /// Holds data from gameinfo.txt. /// </summary> public class GameInfoFormat { public KeyValuesFormat KeyValues; // Data public string GameName; public int SteamAppID; public GameInfoFormat(string content) { // Load KeyValues KeyValues = new KeyValuesFormat(content); // Populate Data GameName = (string) KeyValues.GetKeyValue(\"game\").Value; SteamAppID = (int) KeyValues.GetKeyValue(\"SteamAppId\").Value; } }","title":"KeyValues"},{"location":"fileformats/keyvalues/#keyvalues-file-format","text":"During Mod development, you might need to store data in an easy-to-use text format. For this purpose, we use Valve's KeyValues format.","title":"KeyValues File Format"},{"location":"fileformats/keyvalues/#parent-keys","text":"Parent Keys contain Nested Parent Keys and Key Values. They are defined by a name, followed by an opening curly brace { , the contents of the Parent Key, and a closing curly brace } . Name { any other parent keys or key values would go here. }","title":"Parent Keys"},{"location":"fileformats/keyvalues/#key-values","text":"Key Values contain accessible variable data in text form. They are defined by a Key (Name), followed by an indent and the desired Value. Name \"Value\"","title":"Key Values"},{"location":"fileformats/keyvalues/#supported-value-datatypes","text":"Type Formatting Example Integer \"123\" Float \"123.1\" Boolean \"true\" String \"string\" Vector3 \"(1 2 3)\" OR \"1 2 3\" Vector4 \"(1 2 3 4)\" OR \"1 2 3 4\"","title":"Supported Value Datatypes"},{"location":"fileformats/keyvalues/#c-api","text":"The KeyValues Format can be parsed through the KeyValuesFormat Class. This Class breaks a KeyValues file into the following structure. ParentKey \u251c\u2500\u2500 ChildParentKey \u2502 \u251c\u2500\u2500 ChildKeyValue \u2502 \u2514\u2500\u2500 ChildKeyValue \u2514\u2500\u2500 ChildKeyValue To parse a KeyValue file using the C# API, first read the file contents, then create a new instance of the KeyValuesFormat class like this: new KeyValuesFormat(file_contents)","title":"C# API"},{"location":"fileformats/keyvalues/#gameinfo-example","text":"The following is an example of parsing a KeyValues file and getting Values from it to parse GameInfo.txt: /// <summary> /// Holds data from gameinfo.txt. /// </summary> public class GameInfoFormat { public KeyValuesFormat KeyValues; // Data public string GameName; public int SteamAppID; public GameInfoFormat(string content) { // Load KeyValues KeyValues = new KeyValuesFormat(content); // Populate Data GameName = (string) KeyValues.GetKeyValue(\"game\").Value; SteamAppID = (int) KeyValues.GetKeyValue(\"SteamAppId\").Value; } }","title":"GameInfo Example"},{"location":"filesystem/filesystem/","text":"Working With Files PlaceholderMod uses a unique file structure, utilising features such as mounted game support. The C# API provides comprehensive functionality for managing and working with files across game-specific and mounted folders and packages. Getting an Asset Path Each asset type has an associated FileSystem function to get its path. For example, GetMaterialPath(\"metal/material_name\") will return the path to a .vmt file called 'material_name' inside 'materials/metal'. Getting an Asset Some asset types support directly retrieving their type through a FileSystem function. For example, GetMaterial(\"material_name\") will return the Material object for 'material_name'. Asset Search Paths When getting an Asset by its path or reference, the File System will first search the Game directory. If it fails to find the Asset in the Game directory, it will then search mounted Game directories. This causes local Game Assets to always take priority over mounted Game Assets.","title":"Working With Files"},{"location":"filesystem/filesystem/#working-with-files","text":"PlaceholderMod uses a unique file structure, utilising features such as mounted game support. The C# API provides comprehensive functionality for managing and working with files across game-specific and mounted folders and packages.","title":"Working With Files"},{"location":"filesystem/filesystem/#getting-an-asset-path","text":"Each asset type has an associated FileSystem function to get its path. For example, GetMaterialPath(\"metal/material_name\") will return the path to a .vmt file called 'material_name' inside 'materials/metal'.","title":"Getting an Asset Path"},{"location":"filesystem/filesystem/#getting-an-asset","text":"Some asset types support directly retrieving their type through a FileSystem function. For example, GetMaterial(\"material_name\") will return the Material object for 'material_name'.","title":"Getting an Asset"},{"location":"filesystem/filesystem/#asset-search-paths","text":"When getting an Asset by its path or reference, the File System will first search the Game directory. If it fails to find the Asset in the Game directory, it will then search mounted Game directories. This causes local Game Assets to always take priority over mounted Game Assets.","title":"Asset Search Paths"},{"location":"filesystem/gameinfo/","text":"GameInfo PlaceholderMod, like Source Engine mods, includes a gameinfo.txt file in its root Game directory. During development you may need to access the contents stored in the gameinfo.txt file through the C# API. Accessing GameInfo.txt The game's gameinfo.txt can be accessed through the GameInfo class. Since gameinfo.txt uses the KeyValues format, the class provides standard functions for collecting data from KeyValues, along with gameinfo-specific functions. Game Specific Data Function Data GameInfo Definition GetGameName() Game Name/Title. Defined in the game KeyValue GetSteamAppID() Steam App ID of the Mounted Game. Defined in the SteamAppId KeyValue GetMountedPaths() Path of all Mounted Games. Defined in the Game KeyValue(s)","title":"GameInfo"},{"location":"filesystem/gameinfo/#gameinfo","text":"PlaceholderMod, like Source Engine mods, includes a gameinfo.txt file in its root Game directory. During development you may need to access the contents stored in the gameinfo.txt file through the C# API.","title":"GameInfo"},{"location":"filesystem/gameinfo/#accessing-gameinfotxt","text":"The game's gameinfo.txt can be accessed through the GameInfo class. Since gameinfo.txt uses the KeyValues format, the class provides standard functions for collecting data from KeyValues, along with gameinfo-specific functions.","title":"Accessing GameInfo.txt"},{"location":"filesystem/gameinfo/#game-specific-data","text":"Function Data GameInfo Definition GetGameName() Game Name/Title. Defined in the game KeyValue GetSteamAppID() Steam App ID of the Mounted Game. Defined in the SteamAppId KeyValue GetMountedPaths() Path of all Mounted Games. Defined in the Game KeyValue(s)","title":"Game Specific Data"},{"location":"gui/elementmanipulation/","text":"Element Manipulation The C# API provides many methods of manipulating Elements on the Front-End from code. Getting an Element A C# reference to an Element can be obtained using GetElementAsType<ElementType>(ElementID) . However, not every front-end element has a direct C# equivalent. In cases like this, you can use the generic VistaElement Type as an alternative. Some Elements don't have a direct C# equivalent but instead have a more general Type. For instance, all Text Elements use the VistaText Type. Modifying an Element Element references offer various functions for changing properties, HTML, style, and more. Each Element Type has it's own specific methods for changing content related to that Type. For example, VistaImage has an 'ImageSource' variable that determines the file path for the image, while VistaText has a 'TextContent' variable that controls the Text inside the Element. However, there are generic methods that all Elements share. Function Purpose SetInnerHTML(html) Sets the InnerHTML Property of the Element. SetProperty(property, value) Sets a Property of the Element. SetStyle(style) Sets the Style (CSS) of the Element. These generic functions typically have a corresponding 'Get' version that retrieves the value instead of setting it. For example, GetStyle() will return the Elements CSS. Examples Changing Image Source via VistaElement and VistaImage // Change the Image Source of a generic VistaElement. VistaElement imageElement = GetElementAsType<VistaElement>(\"image\"); imageElement.SetProperty(\"src\", \"file:///images/test_image.png\"); // Change the Image Source of a VistaImage VistaImage imageElement = GetElementAsType<VistaImage>(\"image\"); imageElement.ImageSource = \"file:///images/test_image.png\";","title":"Element Manipulation"},{"location":"gui/elementmanipulation/#element-manipulation","text":"The C# API provides many methods of manipulating Elements on the Front-End from code.","title":"Element Manipulation"},{"location":"gui/elementmanipulation/#getting-an-element","text":"A C# reference to an Element can be obtained using GetElementAsType<ElementType>(ElementID) . However, not every front-end element has a direct C# equivalent. In cases like this, you can use the generic VistaElement Type as an alternative. Some Elements don't have a direct C# equivalent but instead have a more general Type. For instance, all Text Elements use the VistaText Type.","title":"Getting an Element"},{"location":"gui/elementmanipulation/#modifying-an-element","text":"Element references offer various functions for changing properties, HTML, style, and more. Each Element Type has it's own specific methods for changing content related to that Type. For example, VistaImage has an 'ImageSource' variable that determines the file path for the image, while VistaText has a 'TextContent' variable that controls the Text inside the Element. However, there are generic methods that all Elements share. Function Purpose SetInnerHTML(html) Sets the InnerHTML Property of the Element. SetProperty(property, value) Sets a Property of the Element. SetStyle(style) Sets the Style (CSS) of the Element. These generic functions typically have a corresponding 'Get' version that retrieves the value instead of setting it. For example, GetStyle() will return the Elements CSS.","title":"Modifying an Element"},{"location":"gui/elementmanipulation/#examples","text":"Changing Image Source via VistaElement and VistaImage // Change the Image Source of a generic VistaElement. VistaElement imageElement = GetElementAsType<VistaElement>(\"image\"); imageElement.SetProperty(\"src\", \"file:///images/test_image.png\"); // Change the Image Source of a VistaImage VistaImage imageElement = GetElementAsType<VistaImage>(\"image\"); imageElement.ImageSource = \"file:///images/test_image.png\";","title":"Examples"},{"location":"gui/events/","text":"Events An Event is a function that is triggered from HTML or JavaScript and then executes code via the C# API. Calling an Event is just like calling a JavaScript function, for example, using onclick=\"EventName()\" inside a button will call the 'EventName()' Event assuming the function isn't already defined inside JavaScript. Registering an Event inside C# is done by running RegisterEvent(\"EventName\", Action); on a GUICanvas component. This will trigger the specified Action when 'EventName()' is called. Unregistering Events Events should be unregistered when the associated component is destroyed, you can unregister events through UnregisterEvent(\"EventName\") in the OnDestroy() method. Examples Setting Text with an Event <button onclick=\"SetText()\">Set Text</button> <p id=\"text-label\">Original Text</p> // Sets Text of a Text-Based Element when \"SetText()\" Event is called from JS. RegisterEvent(\"SetText\", () => SetText()); void SetText() { // Set Text VistaText textElement = GetElementAsType<VistaText>(\"text-label\"); textElement.TextContent = \"Set Text Content!\"; }","title":"Events"},{"location":"gui/events/#events","text":"An Event is a function that is triggered from HTML or JavaScript and then executes code via the C# API. Calling an Event is just like calling a JavaScript function, for example, using onclick=\"EventName()\" inside a button will call the 'EventName()' Event assuming the function isn't already defined inside JavaScript. Registering an Event inside C# is done by running RegisterEvent(\"EventName\", Action); on a GUICanvas component. This will trigger the specified Action when 'EventName()' is called.","title":"Events"},{"location":"gui/events/#unregistering-events","text":"Events should be unregistered when the associated component is destroyed, you can unregister events through UnregisterEvent(\"EventName\") in the OnDestroy() method.","title":"Unregistering Events"},{"location":"gui/events/#examples","text":"Setting Text with an Event <button onclick=\"SetText()\">Set Text</button> <p id=\"text-label\">Original Text</p> // Sets Text of a Text-Based Element when \"SetText()\" Event is called from JS. RegisterEvent(\"SetText\", () => SetText()); void SetText() { // Set Text VistaText textElement = GetElementAsType<VistaText>(\"text-label\"); textElement.TextContent = \"Set Text Content!\"; }","title":"Examples"},{"location":"gui/intro/","text":"Intro to VistaGUI VistaGUI is the complete replacement for the GUI System, phasing out Source Engine's outdated VGUI . VistaGUI is more similar in workflow to Valve's newer GUI System, Panorama , by heavily utilizing Web Development techniques. Front-End A VistaGUI Frontend is built using standard Web Development tools like HTML, CSS and optionally JavaScript. Unlike typical HTML, however, it doesn't require defining metadata or specifying itself as HTML. Back-End (Engine Interaction) When building a GUI, it will eventually need to integrate with the Engine. In Vista, this is done through Events . An Event is triggered from HTML or JavaScript and then executes code via the C# API. Combining JavaScript and C# With the option of two seperate scripting languages, it can be difficult to determine when to use each one. Generally, JavaScript should be used for all functionality that doesn't require Engine interaction, while C# should be used for anything that involves Engine interaction. Using JavaScript for Front-End isn't a necessity as C# can be used for functionality typically handled by JavaScript. However, JavaScript has no access to the Scripting API and cannot manipulate the Engine alone.","title":"Intro to VistaGUI"},{"location":"gui/intro/#intro-to-vistagui","text":"VistaGUI is the complete replacement for the GUI System, phasing out Source Engine's outdated VGUI . VistaGUI is more similar in workflow to Valve's newer GUI System, Panorama , by heavily utilizing Web Development techniques.","title":"Intro to VistaGUI"},{"location":"gui/intro/#front-end","text":"A VistaGUI Frontend is built using standard Web Development tools like HTML, CSS and optionally JavaScript. Unlike typical HTML, however, it doesn't require defining metadata or specifying itself as HTML.","title":"Front-End"},{"location":"gui/intro/#back-end-engine-interaction","text":"When building a GUI, it will eventually need to integrate with the Engine. In Vista, this is done through Events . An Event is triggered from HTML or JavaScript and then executes code via the C# API.","title":"Back-End (Engine Interaction)"},{"location":"gui/intro/#combining-javascript-and-c","text":"With the option of two seperate scripting languages, it can be difficult to determine when to use each one. Generally, JavaScript should be used for all functionality that doesn't require Engine interaction, while C# should be used for anything that involves Engine interaction. Using JavaScript for Front-End isn't a necessity as C# can be used for functionality typically handled by JavaScript. However, JavaScript has no access to the Scripting API and cannot manipulate the Engine alone.","title":"Combining JavaScript and C#"},{"location":"gui/tutorials/","text":"Tutorials Creating a Screenspace GUI Entity In this tutorial, we'll create an Entity that renders a VistaGUI Canvas to the screen when placed in a Map and add a button to generate a random number, all written in C#. To get started, create a new blank Entity in your project that inherits from ScreenspaceGUICanvas and implements the Start() method. This file can have any name, but for this Tutorial we will be naming it MyScreenspaceCanvas.cs . public class MyScreenspaceCanvas : ScreenspaceGUICanvas { // This function will run once on start. public override void Start() { } } Now we have an empty GUI Entity that we can use in-game, but we haven't created a GUI to render yet. Let's make a new .html file inside our game's gui folder. For this tutorial, we'll name the file my-screenspace.html . Next, we can open this file and define some Elements to render. VistaGUI HTML consists of a <head> section and a <body> section. The <body> contains all the visible Elements in the Canvas, while the <head> contains things like CSS styling and meta-data. <head> <!-- We don't have any styling, so we leave the head empty. --> </head> <body> <button>Click Me!</button> </body> This will add a single Button with the text \"Click Me!\" inside. Now, let's tell our Entity that we want to render this file. public class MyScreenspaceCanvas : ScreenspaceGUICanvas { // This function will run once on start. public override void Start() { // Let the Entity know which .html file to render PanelName = \"my-screenspace.html\"; } } Now we have an Entity linked to a valid Vista HTML file, but if you try to use it you'll notice that nothing renders. This is because we need to tell the Entity to start the GUI once it's configured. We can do this in the Start() method by using base.Start(); like so: public class MyScreenspaceCanvas : ScreenspaceGUICanvas { // This function will run once on start. public override void Start() { // Let the Entity know which .html file to render PanelName = \"my-screenspace.html\"; // Start the GUI base.Start(); } } Now that we have a Canvas rendering to the screen with a button inside, let's add some functionality and allow it to generate a random number when pressed. Functionality VistaGUI can interact with the front-end within the C# API via the Events System. In this tutorial, we'll be using C# exclusively. However, VistaGUI also supports JavaScript and recommends using it for code that isn't engine-dependent. For more information on the relationship between JavaScript and C#, refer to the Intro to VistaGUI page. Let's get started by triggering an event inside our previously created .html file using our buttons onclick attribute. <head> <!-- We don't have any styling, so we leave the head empty. --> </head> <body> <button onclick=\"GenerateNumber()\">Click Me!</button> </body> Now, let's register some code to run when our GenerateNumber event gets triggered inside our Entity using RegisterEvent . public class MyScreenspaceCanvas : ScreenspaceGUICanvas { // This function will run once on start. public override void Start() { // Let the Entity know which .html file to render PanelName = \"my-screenspace.html\"; // Start the GUI base.Start(); // Register the \"GenerateNumber\" Event RegisterEvent(\"GenerateNumber\", GenerateNumber()); void GenerateNumber() { Console.WriteLine(\"Pressed Button!\"); } } } Tip RegisterEvent() Will run any Action , it doesn't have to be a defined function. Clicking our Button will now log \"Pressed Button!\" to the Console. Let's add another level of interaction by making our button affect a Text element in our GUI. We'll start by adding another Element to our .html file. <head> <!-- We don't have any styling, so we leave the head empty. --> </head> <body> <p>My Text</p> <button onclick=\"GenerateNumber()\">Click Me!</button> </body> Now we have a <p> Element rendering 'My Text' in our GUI. Let's expose this to our Entity code by using an id attribute. <head> <!-- We don't have any styling, so we leave the head empty. --> </head> <body> <p id=\"my-text-element\">My Text</p> <button onclick=\"GenerateNumber()\">Click Me!</button> </body> We can now get a reference to this Element inside our Entity with the following code: public class MyScreenspaceCanvas : ScreenspaceGUICanvas { // This function will run once on start. public override void Start() { // Let the Entity know which .html file to render PanelName = \"my-screenspace.html\"; // Start the GUI base.Start(); // Register the \"GenerateNumber\" Event RegisterEvent(\"GenerateNumber\", GenerateNumber()); void GenerateNumber() { // Get our Text Element VistaText myTextElement = Canvas.GetElementAsType<VistaText>(\"my-text-element\"); } } } Let's finish our Entity by generating a random number and setting our Elements Text using myTextElement.TextContent = \"Text Goes Here\" . public class MyScreenspaceCanvas : ScreenspaceGUICanvas { // This function will run once on start. public override void Start() { // Let the Entity know which .html file to render PanelName = \"my-screenspace.html\"; // Start the GUI base.Start(); // Register the \"GenerateNumber\" Event RegisterEvent(\"GenerateNumber\", GenerateNumber()); void GenerateNumber() { // Get our Text Element VistaText myTextElement = Canvas.GetElementAsType<VistaText>(\"my-text-element\"); // Generate a random number (0-100) Random random = new Random(); int randomNumber = random.Next(0, 101); // Set our Text to the number myTextElement.TextContent = randomNumber.ToString(); } } } Congratulations! You should now have a functional random number generator using VistaGUI.","title":"Tutorials"},{"location":"gui/tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"gui/tutorials/#creating-a-screenspace-gui-entity","text":"In this tutorial, we'll create an Entity that renders a VistaGUI Canvas to the screen when placed in a Map and add a button to generate a random number, all written in C#. To get started, create a new blank Entity in your project that inherits from ScreenspaceGUICanvas and implements the Start() method. This file can have any name, but for this Tutorial we will be naming it MyScreenspaceCanvas.cs . public class MyScreenspaceCanvas : ScreenspaceGUICanvas { // This function will run once on start. public override void Start() { } } Now we have an empty GUI Entity that we can use in-game, but we haven't created a GUI to render yet. Let's make a new .html file inside our game's gui folder. For this tutorial, we'll name the file my-screenspace.html . Next, we can open this file and define some Elements to render. VistaGUI HTML consists of a <head> section and a <body> section. The <body> contains all the visible Elements in the Canvas, while the <head> contains things like CSS styling and meta-data. <head> <!-- We don't have any styling, so we leave the head empty. --> </head> <body> <button>Click Me!</button> </body> This will add a single Button with the text \"Click Me!\" inside. Now, let's tell our Entity that we want to render this file. public class MyScreenspaceCanvas : ScreenspaceGUICanvas { // This function will run once on start. public override void Start() { // Let the Entity know which .html file to render PanelName = \"my-screenspace.html\"; } } Now we have an Entity linked to a valid Vista HTML file, but if you try to use it you'll notice that nothing renders. This is because we need to tell the Entity to start the GUI once it's configured. We can do this in the Start() method by using base.Start(); like so: public class MyScreenspaceCanvas : ScreenspaceGUICanvas { // This function will run once on start. public override void Start() { // Let the Entity know which .html file to render PanelName = \"my-screenspace.html\"; // Start the GUI base.Start(); } } Now that we have a Canvas rendering to the screen with a button inside, let's add some functionality and allow it to generate a random number when pressed.","title":"Creating a Screenspace GUI Entity"},{"location":"gui/tutorials/#functionality","text":"VistaGUI can interact with the front-end within the C# API via the Events System. In this tutorial, we'll be using C# exclusively. However, VistaGUI also supports JavaScript and recommends using it for code that isn't engine-dependent. For more information on the relationship between JavaScript and C#, refer to the Intro to VistaGUI page. Let's get started by triggering an event inside our previously created .html file using our buttons onclick attribute. <head> <!-- We don't have any styling, so we leave the head empty. --> </head> <body> <button onclick=\"GenerateNumber()\">Click Me!</button> </body> Now, let's register some code to run when our GenerateNumber event gets triggered inside our Entity using RegisterEvent . public class MyScreenspaceCanvas : ScreenspaceGUICanvas { // This function will run once on start. public override void Start() { // Let the Entity know which .html file to render PanelName = \"my-screenspace.html\"; // Start the GUI base.Start(); // Register the \"GenerateNumber\" Event RegisterEvent(\"GenerateNumber\", GenerateNumber()); void GenerateNumber() { Console.WriteLine(\"Pressed Button!\"); } } } Tip RegisterEvent() Will run any Action , it doesn't have to be a defined function. Clicking our Button will now log \"Pressed Button!\" to the Console. Let's add another level of interaction by making our button affect a Text element in our GUI. We'll start by adding another Element to our .html file. <head> <!-- We don't have any styling, so we leave the head empty. --> </head> <body> <p>My Text</p> <button onclick=\"GenerateNumber()\">Click Me!</button> </body> Now we have a <p> Element rendering 'My Text' in our GUI. Let's expose this to our Entity code by using an id attribute. <head> <!-- We don't have any styling, so we leave the head empty. --> </head> <body> <p id=\"my-text-element\">My Text</p> <button onclick=\"GenerateNumber()\">Click Me!</button> </body> We can now get a reference to this Element inside our Entity with the following code: public class MyScreenspaceCanvas : ScreenspaceGUICanvas { // This function will run once on start. public override void Start() { // Let the Entity know which .html file to render PanelName = \"my-screenspace.html\"; // Start the GUI base.Start(); // Register the \"GenerateNumber\" Event RegisterEvent(\"GenerateNumber\", GenerateNumber()); void GenerateNumber() { // Get our Text Element VistaText myTextElement = Canvas.GetElementAsType<VistaText>(\"my-text-element\"); } } } Let's finish our Entity by generating a random number and setting our Elements Text using myTextElement.TextContent = \"Text Goes Here\" . public class MyScreenspaceCanvas : ScreenspaceGUICanvas { // This function will run once on start. public override void Start() { // Let the Entity know which .html file to render PanelName = \"my-screenspace.html\"; // Start the GUI base.Start(); // Register the \"GenerateNumber\" Event RegisterEvent(\"GenerateNumber\", GenerateNumber()); void GenerateNumber() { // Get our Text Element VistaText myTextElement = Canvas.GetElementAsType<VistaText>(\"my-text-element\"); // Generate a random number (0-100) Random random = new Random(); int randomNumber = random.Next(0, 101); // Set our Text to the number myTextElement.TextContent = randomNumber.ToString(); } } } Congratulations! You should now have a functional random number generator using VistaGUI.","title":"Functionality"},{"location":"modding/codemods/","text":"Code Mods Code Mods are mods that interface with the C# API to introduce new features, usually in the form of Game Components or something similar. They are highly versatile, both the Game code and the Editor code are Code Mods. Creating a Code Mod To create a Code Mod, place a .dll file linked to Engine.dll inside the bin/mods folder. By default, all Game Components defined in the mod's .dll will be usable in-game automatically. Mod Entry-Points Mods can optionally define an \"Entry-Point\" which allows the Mod to automatically run code when it is loaded or unloaded by the engine. To add an Entry-Point to your Mod, create a class that inherits from the IMod interface and implement both the OnLoad() and OnUnload() methods. // Entry-Point for 'MyMod' public class MyMod : IMod { // Runs once on Mod Load public void OnLoad() { } // Runs once on Mod Unload public void OnUnload() { } } A Mod can have any number of Entry-Points, but for the sake of convenience and organization, it's recommended to have only one. Mod Clean Up Each Mod should ideally manage itself through it's Entry-Point's OnLoad() and OnUnload() methods, if applicable. This means any actions performed by the Mod during loading should be undone when the Mod is unloaded. For example, if a GameObject is created in OnLoad() , it should be destroyed in OnUnload() .","title":"Code Mods"},{"location":"modding/codemods/#code-mods","text":"Code Mods are mods that interface with the C# API to introduce new features, usually in the form of Game Components or something similar. They are highly versatile, both the Game code and the Editor code are Code Mods.","title":"Code Mods"},{"location":"modding/codemods/#creating-a-code-mod","text":"To create a Code Mod, place a .dll file linked to Engine.dll inside the bin/mods folder. By default, all Game Components defined in the mod's .dll will be usable in-game automatically.","title":"Creating a Code Mod"},{"location":"modding/codemods/#mod-entry-points","text":"Mods can optionally define an \"Entry-Point\" which allows the Mod to automatically run code when it is loaded or unloaded by the engine. To add an Entry-Point to your Mod, create a class that inherits from the IMod interface and implement both the OnLoad() and OnUnload() methods. // Entry-Point for 'MyMod' public class MyMod : IMod { // Runs once on Mod Load public void OnLoad() { } // Runs once on Mod Unload public void OnUnload() { } } A Mod can have any number of Entry-Points, but for the sake of convenience and organization, it's recommended to have only one.","title":"Mod Entry-Points"},{"location":"modding/codemods/#mod-clean-up","text":"Each Mod should ideally manage itself through it's Entry-Point's OnLoad() and OnUnload() methods, if applicable. This means any actions performed by the Mod during loading should be undone when the Mod is unloaded. For example, if a GameObject is created in OnLoad() , it should be destroyed in OnUnload() .","title":"Mod Clean Up"},{"location":"modding/intro/","text":"Intro To Modding By default, PlaceholderMod ships with enhanced modding support for both Content and Code mods. While mods cannot modify existing engine code, they can extend it by adding features like scripted Game Components. Mods are highly versatile and capable. For instance, the Editor itself is an Engine Mod. Content Mods Content Mods are similar to typical Portal 2 Mods, adding things like Maps, Models, Materials, etc., but they don't alter or extend the underlying code. Note: Full support for Content Mods is still in development. For now, you can simply replace/add to files. Code Mods Code Mods differ from Content Mods in that they introduce custom features defined through code. These mods compile to a .dll file and are loaded by the Engine during runtime. Total-Conversion Mods When Content Mods and Code Mods are combined on a high level, they form a Total-Conversion mod. These mods can function as standalone games with their own executables and binaries and in some cases not requiring PlaceholdeeMod to be installed at all.","title":"Intro to Modding"},{"location":"modding/intro/#intro-to-modding","text":"By default, PlaceholderMod ships with enhanced modding support for both Content and Code mods. While mods cannot modify existing engine code, they can extend it by adding features like scripted Game Components. Mods are highly versatile and capable. For instance, the Editor itself is an Engine Mod.","title":"Intro To Modding"},{"location":"modding/intro/#content-mods","text":"Content Mods are similar to typical Portal 2 Mods, adding things like Maps, Models, Materials, etc., but they don't alter or extend the underlying code. Note: Full support for Content Mods is still in development. For now, you can simply replace/add to files.","title":"Content Mods"},{"location":"modding/intro/#code-mods","text":"Code Mods differ from Content Mods in that they introduce custom features defined through code. These mods compile to a .dll file and are loaded by the Engine during runtime.","title":"Code Mods"},{"location":"modding/intro/#total-conversion-mods","text":"When Content Mods and Code Mods are combined on a high level, they form a Total-Conversion mod. These mods can function as standalone games with their own executables and binaries and in some cases not requiring PlaceholdeeMod to be installed at all.","title":"Total-Conversion Mods"}]}